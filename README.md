Для начала я написала 4 алгоритма: два указателя(время - o(n+m), память - o(1)), бин поиск(время - o(mlogn), память - o(1)), экспоненциальный поиск(время - o(mlog(2n/m)), память - o(1)), 
бин поиск с разделением(время - o(mlog(2n/m), память - o(logm)), где m<=n. Сравнив ассимптотики по времени каждого алгоритма, можно расставить алгоритмы в порядке от самого быстрого к самому медленному:<br/>
1.два указателя(самый быстрый работает за линейное время)<br/>
2.бин поиск<br/>
3.бин поиск с разделением, экспоненциальный поиск (имеют одинаковую асимптотику по времени)<br/>


Теперь с помощью numpy напишем [код для генерации тестов](lab1/tests.py), а потом с помощью matplotlib [код для их запуска](lab1/run_tests.py). На графике ось x - логарифмическая(отвечает за память),
а y - за время. 

Для начала проведем тест с рандомными данными, где значения варьируются от 0 до 10^9, а размеры массивов от 10 до 10^5. По [этому графику](lab1/graphics/graph_random.png) можно сделать вывод, что производить замеры на рандомных данных неэффективно, так как они нестабильны и по ним нельзя достоверно сравнить скорость каждого алгоритма:

<img width="440" height="280" alt="graph_random" src="https://github.com/user-attachments/assets/8031c392-e614-46ff-bac7-551fec1f1a34" />

Теперь проведем тесты с данными генерирующими два массива с разной четностью([1 график](lab1/graphics/graph_dif_chet.png)), и с равномерным распределением данных в массиве([2 график](lab1/graphics/graph_ravnomerno.png)), и совместим разную четность с равномерным распределением([3 график](lab1/graphics/graph_ravn_dif_chet.png)). По графикам видно, что скорость выполнения больше всего растет у экспоненциального поиска, а меньше всего у двух указателей:

<img width="440" height="280" alt="graph_dif_chet" src="https://github.com/user-attachments/assets/9b99c0dd-974e-49d6-9f8b-462dba8fc8d3" />  <img width="440" height="280" alt="graph_ravnomerno" src="https://github.com/user-attachments/assets/3a40dbcc-d496-4709-a7b8-ad0fa78b5b87" />  <img width="440" height="280" alt="graph_ravn_dif_chet" src="https://github.com/user-attachments/assets/6f63a2e1-af28-4810-8aa5-fcc9a21b7697" />

Далее я провела тесты с маленькими данными в массивах([график 1](lab1/graphics/graph_min_value.png)) и с большими данными([график 2](lab1/graphics/graph_big_value.png)), при этом используя равномерное распределение данных в массивах, и сравнила их. По графикам можно сделать вывод, что размер значений не влияет на асимптотику по времени(единственное с маленькими значениями график чуть стабильнее):

<img width="440" height="280" alt="graph_min_value" src="https://github.com/user-attachments/assets/bedda4c7-bc3d-42a2-8304-e7d4b67429a3" />  <img width="440" height="280" alt="graph_big_value" src="https://github.com/user-attachments/assets/0930bace-8e7c-47f6-997b-23dfdccd3660" />

Следующий тест я провела на массивах с одинаковыми данными(в каждом массиве одно уникальное значение), по [графику](lab1/graphics/graph_same_value.png) видно, что он сильно отличается от остальных, здесь уже самы медленный алгоритм - бин поиск, а самый быстрый бин поиск с разделением, он вообще почти не растет:

<img width="440" height="280" alt="graph_same_value" src="https://github.com/user-attachments/assets/e0afb2b8-b12f-4c24-ac5a-a8a08d6849a2" />

В самом конце я провела тесты на маленьких данных(размер массивов от 10 до 10^2), [первый график](lab1/graphics/graph_min_array_ravnomern_dif_chet.png) - равномерное распределение с разной четностью, [второй](lab1/graphics/graph_min_array_dif_lenght.png) - с разной длинной массивов.По первому графику видно, что экспоненциальный поиск работает дольше всего(так как совершает большие скачки и потом проходится почти по всему массиву), а два указателя опять же самый медленно растущий. По второму графику можно сказать, что на маленьких данных скорость выполнения больше всего растет у двух указателей, а меньше всего у бин поиска и бин поиска с разделением:

<img width="440" height="280" alt="graph_min_array_ravnomern_dif_chet" src="https://github.com/user-attachments/assets/32be0524-3160-4b81-926a-a7ac56d3dfcf" />  <img width="440" height="280" alt="graph_min_array_dif_lenght" src="https://github.com/user-attachments/assets/96a18ecf-cd66-4f0f-8fd1-44c3b9e87864" />  

Проделав множество тестов, можно сделать вывод, что и для маленьких и для больших данных самым эффективным алгоритмом будут два указателя, а самым неэффективным будет экспоненциальный поиск.
